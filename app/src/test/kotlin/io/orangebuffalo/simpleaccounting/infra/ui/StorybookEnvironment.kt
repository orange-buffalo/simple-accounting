package io.orangebuffalo.simpleaccounting.infra.ui

import com.fasterxml.jackson.databind.DeserializationFeature
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import com.fasterxml.jackson.module.kotlin.readValue
import com.microsoft.playwright.Browser
import com.microsoft.playwright.Page
import io.orangebuffalo.simpleaccounting.infra.environment.TestsEnvironment
import io.orangebuffalo.simpleaccounting.infra.utils.KNginxContainer
import org.junit.jupiter.api.extension.*
import org.testcontainers.containers.BindMode
import org.testcontainers.containers.wait.strategy.HttpWaitStrategy
import java.io.File
import java.net.URI

private val storybookEnvironment = StorybookEnvironment()

private const val storybookDirectory = "../frontend/build/storybook"

private val nginx = KNginxContainer("nginx:1.22")
    .withCustomContent(storybookDirectory)
    .waitingFor(HttpWaitStrategy())
    .withNetwork(TestsEnvironment.network)
    .withNetworkAliases("storybook")
    // nginx does not support mjs generated by storybook, overriding config to enable it
    .withClasspathResourceMapping("/nginx.conf", "/etc/nginx/nginx.conf", BindMode.READ_ONLY)

class StorybookExtension : BeforeEachCallback, Extension, ParameterResolver {
    override fun beforeEach(context: ExtensionContext) {
        // lazy start the container for easier debugging in IDE
        // but keep singleton containers as they start slowly
        if (!TestsEnvironment.browser.isRunning) {
            TestsEnvironment.browser.start()
            if (TestsEnvironment.config.screenshots.useCompliedStorybook) {
                nginx.start()
            }
        }
    }

    override fun supportsParameter(parameterContext: ParameterContext, extensionContext: ExtensionContext): Boolean {
        return parameterContext.parameter.type == StorybookEnvironment::class.java
    }

    override fun resolveParameter(parameterContext: ParameterContext, extensionContext: ExtensionContext): Any {
        return storybookEnvironment
    }
}

class StorybookEnvironment {

    val stories: Collection<StorybookStory>
    val shouldUpdateCommittedScreenshots: Boolean
        get() = TestsEnvironment.config.screenshots.replaceCommittedFiles

    private val pages = ThreadLocal.withInitial {
            val browser = TestsEnvironment.browser.getPlaywrightApi().chromium()
            val context = browser.newContext(
                Browser.NewContextOptions()
                    .setBaseURL(
                        if (TestsEnvironment.config.screenshots.useCompliedStorybook)
                            "http://storybook/"
                        else "http://host.docker.internal:6006/"
                    )
                    .setViewportSize(1358, 687)
            )
            context.setDefaultTimeout(10_000.0)

            Runtime.getRuntime().addShutdownHook(Thread {
                browser.close()
            })

            context.newPage()
        }

    init {
        val storiesJsonUri = if (TestsEnvironment.config.screenshots.useCompliedStorybook)
            File(storybookDirectory, "stories.json").toURI()
        else URI("http://localhost:6006/stories.json")

        val data: StorybookStoriesFileData = jacksonObjectMapper()
            .disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES).readValue(storiesJsonUri.toURL())

        val excludedStories = setOf(
            "components-basic-documents-sadocumentslist--with-deferred-documents",
            "components-basic-documents-sadocumentsupload--with-deferred-documents",
            "components-basic-documents-sadocumentsupload--initial-loading-with-no-documents",
            "components-basic-documents-sadocumentsupload--all-uploads-failing",
            "components-other-notifications--error",
        )
        excludedStories.forEach { skippedStoryId ->
            if (data.stories.values.firstOrNull { story -> story.id == skippedStoryId } == null) {
                throw IllegalStateException("Skipped story $skippedStoryId does not exist")
            }
        }
        stories = data.stories.values.filter { story -> !excludedStories.contains(story.id) }
    }

    fun page(): Page = pages.get()
}

data class StorybookStory(
    val title: String,
    val name: String,
    val id: String,
)

private data class StorybookStoriesFileData(
    val stories: Map<String, StorybookStory>
)
